<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="utf-8">
    <title>tbapi.js - Documentation</title>
    
    
    <script src="scripts/prettify/prettify.js"></script>
    <script src="scripts/prettify/lang-css.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc.css">
    <script src="scripts/nav.js" defer></script>
    
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
</head>
<body>

<input type="checkbox" id="nav-trigger" class="nav-trigger" />
<label for="nav-trigger" class="navicon-button x">
  <div class="navicon"></div>
</label>

<label for="nav-trigger" class="overlay"></label>

<nav >
    
    <input type="text" id="nav-search" placeholder="Search" />
    
    
    <h2><a href="index.html">Home</a></h2><h2><a href="https://github.com/toolbox-team/reddit-moderator-toolbox" target="_blank" class="menu-item" >Github</a></h2><h2><a href="https://www.reddit.com/r/toolbox" target="_blank" class="menu-item" >Subreddit</a></h2><h3>Classes</h3><ul><li><a href="Module.html">Module</a><ul class='methods'><li data-type='method'><a href="Module.html#get">get</a></li><li data-type='method'><a href="Module.html#getEnabled">getEnabled</a></li><li data-type='method'><a href="Module.html#init">init</a></li><li data-type='method'><a href="Module.html#set">set</a></li><li data-type='method'><a href="Module.html#setEnabled">setEnabled</a></li></ul></li><li><a href="TBListener.html">TBListener</a><ul class='methods'><li data-type='method'><a href="TBListener.html#clear">clear</a></li><li data-type='method'><a href="TBListener.html#on">on</a></li><li data-type='method'><a href="TBListener.html#start">start</a></li><li data-type='method'><a href="TBListener.html#stop">stop</a></li></ul></li></ul><h3>Global</h3><ul><li><a href="global.html#RandomFeedback">RandomFeedback</a></li><li><a href="global.html#RandomQuote">RandomQuote</a></li><li><a href="global.html#TBLog">TBLog</a></li><li><a href="global.html#TBsettingsObject">TBsettingsObject</a></li><li><a href="global.html#aboutUser">aboutUser</a></li><li><a href="global.html#actionButton">actionButton</a></li><li><a href="global.html#addModSubsToSidebar">addModSubsToSidebar</a></li><li><a href="global.html#addToSiteTable">addToSiteTable</a></li><li><a href="global.html#addTrophiesToSidebar">addTrophiesToSidebar</a></li><li><a href="global.html#alert">alert</a></li><li><a href="global.html#apiOauthDELETE">apiOauthDELETE</a></li><li><a href="global.html#apiOauthGET">apiOauthGET</a></li><li><a href="global.html#apiOauthPOST">apiOauthPOST</a></li><li><a href="global.html#approveThing">approveThing</a></li><li><a href="global.html#baseDomain">baseDomain</a></li><li><a href="global.html#betaRelease">betaRelease</a></li><li><a href="global.html#browserName">browserName</a></li><li><a href="global.html#button">button</a></li><li><a href="global.html#checkForActions">checkForActions</a></li><li><a href="global.html#checkLoadConditions">checkLoadConditions</a></li><li><a href="global.html#checkReset">checkReset</a></li><li><a href="global.html#cleanSubredditName">cleanSubredditName</a></li><li><a href="global.html#clearCache">clearCache</a></li><li><a href="global.html#clearNotification">clearNotification</a></li><li><a href="global.html#colorNameToHex">colorNameToHex</a></li><li><a href="global.html#contextTrigger">contextTrigger</a></li><li><a href="global.html#createModNote">createModNote</a></li><li><a href="global.html#createModNotesBadge">createModNotesBadge</a></li><li><a href="global.html#createModNotesPopup">createModNotesPopup</a></li><li><a href="global.html#daysToMilliseconds">daysToMilliseconds</a></li><li><a href="global.html#debounce">debounce</a></li><li><a href="global.html#debugInformation">debugInformation</a></li><li><a href="global.html#delay">delay</a></li><li><a href="global.html#deleteModNote">deleteModNote</a></li><li><a href="global.html#displayNotes">displayNotes</a></li><li><a href="global.html#distinguishThing">distinguishThing</a></li><li><a href="global.html#doSettingsUpdates">doSettingsUpdates</a></li><li><a href="global.html#domain">domain</a></li><li><a href="global.html#escapeHTML">escapeHTML</a></li><li><a href="global.html#fetchModSubs">fetchModSubs</a></li><li><a href="global.html#fetchNewsNotes">fetchNewsNotes</a></li><li><a href="global.html#figureOutMulti">figureOutMulti</a></li><li><a href="global.html#filterModdable">filterModdable</a></li><li><a href="global.html#flairPost">flairPost</a></li><li><a href="global.html#flairUser">flairUser</a></li><li><a href="global.html#friendUser">friendUser</a></li><li><a href="global.html#generateNoteTableRow">generateNoteTableRow</a></li><li><a href="global.html#getActions">getActions</a></li><li><a href="global.html#getAnonymizedSettings">getAnonymizedSettings</a></li><li><a href="global.html#getBanState">getBanState</a></li><li><a href="global.html#getCache">getCache</a></li><li><a href="global.html#getCurrentUser">getCurrentUser</a></li><li><a href="global.html#getJSON">getJSON</a></li><li><a href="global.html#getLastActive">getLastActive</a></li><li><a href="global.html#getLastVersion">getLastVersion</a></li><li><a href="global.html#getLatestModNote">getLatestModNote</a></li><li><a href="global.html#getModNotes">getModNotes</a></li><li><a href="global.html#getModSubs">getModSubs</a></li><li><a href="global.html#getModhash">getModhash</a></li><li><a href="global.html#getModlog">getModlog</a></li><li><a href="global.html#getRandomNumber">getRandomNumber</a></li><li><a href="global.html#getRatelimit">getRatelimit</a></li><li><a href="global.html#getRecentModNotes">getRecentModNotes</a></li><li><a href="global.html#getReportReasons">getReportReasons</a></li><li><a href="global.html#getRules">getRules</a></li><li><a href="global.html#getSetting">getSetting</a></li><li><a href="global.html#getSettingAsync">getSettingAsync</a></li><li><a href="global.html#getSettings">getSettings</a></li><li><a href="global.html#getSubredditColors">getSubredditColors</a></li><li><a href="global.html#getTime">getTime</a></li><li><a href="global.html#getToolboxDevs">getToolboxDevs</a></li><li><a href="global.html#getUserDetails">getUserDetails</a></li><li><a href="global.html#handleMessage">handleMessage</a></li><li><a href="global.html#handleTBThings">handleTBThings</a></li><li><a href="global.html#handleThing">handleThing</a></li><li><a href="global.html#hideModActionsThings">hideModActionsThings</a></li><li><a href="global.html#htmlDecode">htmlDecode</a></li><li><a href="global.html#htmlEncode">htmlEncode</a></li><li><a href="global.html#humaniseDays">humaniseDays</a></li><li><a href="global.html#icons">icons</a></li><li><a href="global.html#ignoreReports">ignoreReports</a></li><li><a href="global.html#init">init</a></li><li><a href="global.html#initialLoadPromise">initialLoadPromise</a></li><li><a href="global.html#isConfigValidVersion">isConfigValidVersion</a></li><li><a href="global.html#isEquivalent">isEquivalent</a></li><li><a href="global.html#isModSub">isModSub</a></li><li><a href="global.html#labelColors">labelColors</a></li><li><a href="global.html#labelNames">labelNames</a></li><li><a href="global.html#link">link</a></li><li><a href="global.html#listenerAliases">listenerAliases</a></li><li><a href="global.html#literalRegExp">literalRegExp</a></li><li><a href="global.html#lock">lock</a></li><li><a href="global.html#makeCommentThread">makeCommentThread</a></li><li><a href="global.html#makeQueueOverlay">makeQueueOverlay</a></li><li><a href="global.html#makeSingleComment">makeSingleComment</a></li><li><a href="global.html#makeSubmissionEntry">makeSubmissionEntry</a></li><li><a href="global.html#makeUserSidebar">makeUserSidebar</a></li><li><a href="global.html#markMessageRead">markMessageRead</a></li><li><a href="global.html#markOver18">markOver18</a></li><li><a href="global.html#messageHandlers">messageHandlers</a></li><li><a href="global.html#millisecondsToDays">millisecondsToDays</a></li><li><a href="global.html#minutesToMilliseconds">minutesToMilliseconds</a></li><li><a href="global.html#modbarExists">modbarExists</a></li><li><a href="global.html#moveArrayItem">moveArrayItem</a></li><li><a href="global.html#newModmailSidebar">newModmailSidebar</a></li><li><a href="global.html#niceDateDiff">niceDateDiff</a></li><li><a href="global.html#notification">notification</a></li><li><a href="global.html#overlay">overlay</a></li><li><a href="global.html#pager">pager</a></li><li><a href="global.html#pagerForItems">pagerForItems</a></li><li><a href="global.html#parseComments">parseComments</a></li><li><a href="global.html#parser">parser</a></li><li><a href="global.html#popup">popup</a></li><li><a href="global.html#post">post</a></li><li><a href="global.html#postComment">postComment</a></li><li><a href="global.html#postLink">postLink</a></li><li><a href="global.html#postToWiki">postToWiki</a></li><li><a href="global.html#purify">purify</a></li><li><a href="global.html#purifyObject">purifyObject</a></li><li><a href="global.html#readFromWiki">readFromWiki</a></li><li><a href="global.html#regExpEscape">regExpEscape</a></li><li><a href="global.html#reloadIframe">reloadIframe</a></li><li><a href="global.html#reloadToolbox">reloadToolbox</a></li><li><a href="global.html#remove">remove</a></li><li><a href="global.html#removeLastDirectoryPartOf">removeLastDirectoryPartOf</a></li><li><a href="global.html#removeQuotes">removeQuotes</a></li><li><a href="global.html#removeThing">removeThing</a></li><li><a href="global.html#replaceAll">replaceAll</a></li><li><a href="global.html#replaceTokens">replaceTokens</a></li><li><a href="global.html#saneSort">saneSort</a></li><li><a href="global.html#saneSortAs">saneSortAs</a></li><li><a href="global.html#saveSettingsToBrowser">saveSettingsToBrowser</a></li><li><a href="global.html#searchProfile">searchProfile</a></li><li><a href="global.html#sendMessage">sendMessage</a></li><li><a href="global.html#sendRequest">sendRequest</a></li><li><a href="global.html#setCache">setCache</a></li><li><a href="global.html#setSetting">setSetting</a></li><li><a href="global.html#setSettingAsync">setSettingAsync</a></li><li><a href="global.html#settings">settings</a></li><li><a href="global.html#settingsToObject">settingsToObject</a></li><li><a href="global.html#showNote">showNote</a></li><li><a href="global.html#showNotification">showNotification</a></li><li><a href="global.html#sortBy">sortBy</a></li><li><a href="global.html#standardColors">standardColors</a></li><li><a href="global.html#stickyThread">stickyThread</a></li><li><a href="global.html#stringToColor">stringToColor</a></li><li><a href="global.html#syntaxHighlighterThemeSelect">syntaxHighlighterThemeSelect</a></li><li><a href="global.html#tbRedditEvent">tbRedditEvent</a></li><li><a href="global.html#timeConverterRead">timeConverterRead</a></li><li><a href="global.html#title_to_url">title_to_url</a></li><li><a href="global.html#typeNames">typeNames</a></li><li><a href="global.html#unMarkOver18">unMarkOver18</a></li><li><a href="global.html#unescapeHTML">unescapeHTML</a></li><li><a href="global.html#unescapeJSON">unescapeJSON</a></li><li><a href="global.html#unfriendUser">unfriendUser</a></li><li><a href="global.html#unlock">unlock</a></li><li><a href="global.html#unstickyThread">unstickyThread</a></li><li><a href="global.html#updateModNotesBadge">updateModNotesBadge</a></li><li><a href="global.html#updateModNotesPopup">updateModNotesPopup</a></li><li><a href="global.html#userDetailsPromise">userDetailsPromise</a></li><li><a href="global.html#verifiedSettingsSave">verifiedSettingsSave</a></li><li><a href="global.html#watchForURLChanges">watchForURLChanges</a></li><li><a href="global.html#zlibDeflate">zlibDeflate</a></li><li><a href="global.html#zlibInflate">zlibInflate</a></li></ul>
    
</nav>

<div id="main">
    
    <h1 class="page-title">tbapi.js</h1>
    

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>/**
 * Generic helpers for making requests against the Reddit API.
 */

import browser from 'webextension-polyfill';

import TBLog from './tblog.js';
import * as TBStorage from './tbstorage.js';

const logger = TBLog('TBApi');

// Error codes used in lots of places
export const NO_WIKI_PAGE = 'NO_WIKI_PAGE';
export const WIKI_PAGE_UNKNOWN = 'WIKI_PAGE_UNKNOWN';

/**
 * Sends a generic HTTP request through the background page.
 * @function
 * @param {object} options The options for the AJAX request
 * @param {string} options.endpoint The endpoint to request
 * @param {string} [options.method] The HTTP method to use for the request
 * @param {object} [options.query] Query parameters as an object
 * @param {string} [options.body] Body to send with a POST request, serialized
 * as JSON if not a string
 * @param {boolean?} [options.oauth] If true, the request will be sent on
 * oauth.reddit.com, and the `Authorization` header will be set with the
 * OAuth access token for the logged-in user
 * @param {boolean?} [options.okOnly] If true, non-2xx responses will result
 * in an error being rejected. The error will have a `response` property
 * containing the full `Response` object.
 * @returns {Promise} Resolves to a `Response` object or rejects an `Error`.
 */
export const sendRequest = async ({
    method,
    endpoint,
    query,
    body,
    oauth,
    okOnly,
}) => {
    // Make the request
    const messageReply = await browser.runtime.sendMessage({
        action: 'tb-request',
        method,
        endpoint,
        query,
        body,
        oauth,
        okOnly,
    });

    // The reply from that message will always be an object. It can have these keys:
    // - `error` (true if the request failed, otherwise not present)
    // - `message` (present only with `error`, a string error message)
    // - `response` (response data as an array of arguments to `Response()`)

    if (messageReply.error) {
        // If we get an error, we want to throw an `Error` object.
        const error = new Error(messageReply.message);
        // If we get a response as well, we attach it to the error.
        if (messageReply.response) {
            error.response = new Response(...messageReply.response);
        }
        throw error;
    } else {
        // If we didn't get an error, then we return a `Response`.
        return new Response(...messageReply.response);
    }
};

/**
 * Performs a GET request and promises the body of the response, or the
 * full response object on error.
 * @function
 * @param {string} endpoint The endpoint to request
 * @param {object} data Query parameters as an object
 * @param {object} options Additional options passed to sendRequest()
 */
export const getJSON = (endpoint, query = {}, options = {}) => sendRequest({
    okOnly: true,
    method: 'GET',
    endpoint,
    query,
    ...options,
}).then(response => response.json());

/**
 * Performs a POST request and promises the body of the response, or the
 * full response object on error. Maintains an API similar to `$.post`.
 * @function
 * @param {string} endpoint The endpoint to request
 * @param {object} body The body parameters of the request
 * @param {object} [options] Additional options to TBApi.sendRequest
 * @returns {Promise} Resolves to response data or rejects an error
 */
export const post = (endpoint, body, options = {}) => sendRequest({
    okOnly: true,
    method: 'POST',
    endpoint,
    body,
    ...options,
}).then(response => response.json());

/**
 * Sends an authenticated POST request against the OAuth API.
 * @function
 * @param {string} endpoint The endpoint to request
 * @param {object} body Body parameters as an object
 * @param {object} [options] Additional options to TBApi.sendRequest
 */
export const apiOauthPOST = (endpoint, body, options = {}) => sendRequest({
    method: 'POST',
    oauth: true,
    endpoint,
    body,
    okOnly: true,
    ...options,
});

/**
 * Sends an authenticated GET request against the OAuth API.
 * @function
 * @param {string} endpoint The endpoint to request
 * @param {object} data Query parameters as an object
 */
export const apiOauthGET = (endpoint, query) => sendRequest({
    method: 'GET',
    oauth: true,
    endpoint,
    query,
    okOnly: true,
});

/**
 * Sends an authenticated DELETE request against the OAuth API.
 * @function
 * @param {string} endpoint The endpoint to request
 * @param {object} query Query parameters as an object
 * @returns {Promise}
 */
export const apiOauthDELETE = (endpoint, query) => sendRequest({
    method: 'DELETE',
    oauth: true,
    endpoint,
    query,
    okOnly: true,
});

/**
 * A promise that will fulfill with details about the current user, or reject if
 * user details can't be fetched. May return a cached details object if multiple
 * timeouts are encountered.
 * @type {Promise&lt;object | undefined>} JSON response from `/api/me.json`
 */
const userDetailsPromise = (async function fetchUserDetails (tries = 3) {
    try {
        const data = await getJSON('/api/me.json');
        TBStorage.purifyObject(data);
        TBStorage.setCache('Utils', 'userDetails', data);
        return data;
    } catch (error) {
        // 504 Gateway Timeout errors can be retried
        if (error.response &amp;&amp; error.response.status === 504 &amp;&amp; tries > 1) {
            return fetchUserDetails(tries - 1);
        }

        // Throw all other errors without retrying
        throw error;
    }
})()
    // If getting details from API fails, fall back to the cached value (if any)
    .catch(() => TBStorage.getCache('Utils', 'userDetails'));

/**
 * Gets details about the current user.
 * @returns {Promise&lt;object>}
 */
export const getUserDetails = () => userDetailsPromise;

/**
 * Gets the modhash of the currently signed-in user.
 * @returns {Promise&lt;string>}
 */
export const getModhash = async () => {
    const userDetails = await getUserDetails();
    return userDetails.data.modhash;
};

/**
 * Gets the username of the currently signed-in user.
 * @returns {Promise&lt;string>}
 */
export const getCurrentUser = async () => {
    const userDetails = await getUserDetails();
    return userDetails.data.name;
};

//
// Reddit 'legacy' API stuff. Still very much in use.
//

/**
 * Gets ratelimit information from the API.
 * @function
 * @returns {Promise&lt;rateLimitDescriptor>}
 */
export const getRatelimit = () => sendRequest({
    method: 'HEAD',
    endpoint: '/r/toolbox/wiki/ratelimit.json',
}).then(response => {
    const ratelimitRemaining = response.headers.get('x-ratelimit-remaining'),
          ratelimitReset = response.headers.get('x-ratelimit-reset');

    logger.log(`ratelimitRemaining: ${ratelimitRemaining} ratelimitReset: ${ratelimitReset / 60}`);

    /**
     * An object describing the current rate limit.
     * @typedef rateLimitDescriptor
     * @property {string} rateLimitRemaining The number of API calls left
     * during this ratelimit period
     * @property {string} rateLimitReset The number of seconds until this
     * ratelimit period ends
     */
    return {
        ratelimitRemaining,
        ratelimitReset,
    };
});

/**
 * Updates the content of a wiki page.
 * @function
 * @param {string} page The name of the wiki page
 * @param {string} subreddit The name of the subreddit the page is in
 * @param {string | object} data The new content of the page
 * @param {string} reason A note for the revision history of the page
 * @param {boolean} isJSON If true, `data` is stringified as JSON first
 * @param {boolean} updateAM If true, all tabs are replaced with 4 spaces
 * @returns {Promise} Resolves with no value or rejects with the jqXHR object
 */
export async function postToWiki (page, subreddit, data, reason, isJSON, updateAM) {
    if (reason) {
        reason = `"${reason}" via toolbox`;
    } else {
        reason = 'updated via toolbox';
    }

    if (isJSON) {
        // Not indenting saves precious bytes.
        data = JSON.stringify(data);
    }

    logger.log(`Posting /r/${subreddit}/api/wiki/edit/${page}`);

    // If we update automoderator we want to replace any tabs with four spaces.
    if (updateAM) {
        data = data.replace(/\t/g, '    ');
    }

    try {
        await post(`/r/${subreddit}/api/wiki/edit`, {
            content: data,
            page,
            reason,
            uh: await getModhash(),
        });
    } catch (error) {
        logger.error(error);
        throw error;
    }

    setTimeout(async () => {
        // Set page access to 'mod only'.
        // HACK: Using sendRequest() rather than post() because this "endpoint"
        //       isn't really part of the API, and doesn't return JSON, but .post()
        //       assumes all endpoints will return JSON
        // TODO: do we really need to do this every time?
        sendRequest({
            okOnly: true,
            method: 'POST',
            endpoint: `/r/${subreddit}/wiki/settings/`,
            query: {
                page,
                listed: true, // hrm, may need to make this a config setting.
                permlevel: 2,
                uh: await getModhash(),
            },
        })

        // Super extra double-secret secure, just to be safe.
            .catch(() => {
                alert('error setting wiki page to mod only access');
                window.location = `https://www.reddit.com/r/${subreddit}/wiki/settings/${page}`;
            });
    }, 500);

    await new Promise(resolve => setTimeout(resolve, 750));
}

/**
 * Reads data from a wiki page
 * @function
 * @param {string} subreddit The name of the subreddit the page is in
 * @param {string} page The name of the page
 * @param {boolean} isJSON If true, data is parsed as JSON before being returned
 * @returns {Promise} Promises the data of the wiki page. If there is an
 * error reading from the page, one of the following error values may be
 * returned:
 * - TBApi.WIKI_PAGE_UNKNOWN
 * - TBApi.NO_WIKI_PAGE
 * If the isJSON `param` was true, then this will be an object. Otherwise,
 * it will be the raw contents of the wiki as a string.
 */
export const readFromWiki = (subreddit, page, isJSON) => new Promise(resolve => {
    // We need to demangle the JSON ourselves, so we have to go about it this way :(
    getJSON(`/r/${subreddit}/wiki/${page}.json`).then(data => {
        const wikiData = data.data.content_md;
        if (!wikiData) {
            resolve(NO_WIKI_PAGE);
            return;
        }
        if (isJSON) {
            let parsedWikiData;
            try {
                parsedWikiData = JSON.parse(wikiData);
            } catch (err) {
                // we should really have a INVAILD_DATA error for this.
                logger.log(err);
                resolve(NO_WIKI_PAGE);
            }
            // Moved out of the try so random exceptions don't erase the entire wiki page
            if (parsedWikiData) {
                resolve(parsedWikiData);
            } else {
                resolve(NO_WIKI_PAGE);
            }
            return;
        }
        // We have valid data, but it's not JSON.
        resolve(wikiData);
    }).catch(async error => {
        logger.error(`Wiki error (${subreddit}/${page}):`, error);
        if (!error.response) {
            resolve(WIKI_PAGE_UNKNOWN);
            return;
        }
        let reason;
        try {
            reason = (await error.response.json()).reason || '';
        } catch (_) {
            reason = 'WIKI_PAGE_UNKNOWN';
        }

        if (reason === 'PAGE_NOT_CREATED' || reason === 'WIKI_DISABLED') {
            resolve(NO_WIKI_PAGE);
        } else {
            // we don't know why it failed, we should not try to write to it.
            resolve(WIKI_PAGE_UNKNOWN);
        }
    });
});

/**
 * Gets the ban state of a user.
 * @function
 * @param {string} subreddit The name of the subreddit to check in
 * @param {string} user The name of the user to check
 * @returns {Promise&lt;?banState>} An object describing the ban, or null
 * if the user is not banned
 */
export const getBanState = async (subreddit, user) => {
    // Fetch ban info for just this one user
    const data = await getJSON(`/r/${subreddit}/about/banned/.json`, {user});
    TBStorage.purifyObject(data);
    // This API sometimes returns weird things if the user isn't banned, so we use .find()
    // to ensure `null` is returned if we don't get information about the right user
    return data.data.children.find(ban => ban.name.toLowerCase() === user.toLowerCase());
};

/**
 * Describes a subreddit ban.
 * @typedef banState
 * @property {string} name The banned user's name
 * @property {string} id The banned user's ID fullname
 * @property {string} note The mod-visible ban note
 * @property {string} date The date the ban was issued
 * @property {?number} days_left If the ban is temporary, the number of days
 * until it expires, otherwise null
 */

/**
 * Sets a flair on a post.
 * @function
 * @param {string} postLink The post's fullname
 * @param {string} subreddit The name of the subreddit the post is in
 * @param {string} text The flair's text
 * @param {string} cssClass The flair's CSS class
 * @returns {Promise}
 */
export const flairPost = async (postLink, subreddit, text, cssClass, templateID) => post('/api/selectflair', {
    api_type: 'json',
    link: postLink,
    text,
    css_class: cssClass,
    flair_template_id: templateID,
    r: subreddit,
    uh: await getModhash(),
});

/**
 * Sets a flair on a user in a subreddit.
 * @function
 * @param {string} user The name of the user
 * @param {string} subreddit The name of the subreddit
 * @param {string} text The flair's text
 * @param {string} cssClass The flair's CSS class
 * @returns {Promise}
 */
export const flairUser = async (user, subreddit, text, cssClass, templateID) => post('/api/selectflair', {
    api_type: 'json',
    name: user,
    r: subreddit,
    text,
    css_class: cssClass,
    flair_template_id: templateID,
    uh: await getModhash(),
});

/**
 * Creates a relationship between a user and a subreddit. This is used for:
 * - Banning users
 * - Wikibanning users
 * - Muting users
 * - Adding moderators
 * - Adding wiki contributors
 * - Accepting moderator invitations
 * Note: This API route is weird and will always return 200 OK with a body
 * looking something like this:
 *     {"json": {"errors": []}}
 * As a result, this method will resolve even if the relationship is not
 * established. Check the contents of the errors array to confirm that the
 * call actually worked. This method may still reject if the network request
 * can't be completed or if Reddit's API returns a different response code
 * (e.g. 401 Unauthorized).
 * @function
 * @param {object} options
 * @param {string} options.user The user to apply the relationship to
 * @param {string} options.action The string for the desired action (see
 * {@link https://www.reddit.com/dev/api#POST_api_friend} for a list)
 * @param {string} options.subreddit The sub to apply the relationship in
 * @param {string} [options.banReason] If banning, the private mod note
 * @param {string} [options.banMessage] If banning, the note sent to the user
 * @param {number} [options.banDuration] If banning, the length of the ban (0
 * or undefined for a permanent ban)
 * @param {string} [options.banContext] If banning, a fullname pointing to the
 * link or comment the user is being banned for
 * @returns {Promise} Resolves to the JSON response body or rejects with a
 * jqXHR object
 */
export async function friendUser ({
    user,
    action,
    subreddit,
    banReason,
    banMessage,
    banDuration,
    banContext,
}) {
    let trimmedBanMessage,
        trimmedBanReason;
    if (action === 'banned') {
        trimmedBanMessage = banMessage.substring(0, 999);
        trimmedBanReason = banReason.substring(0, 300);
        if (banDuration) {
            if (banDuration > 999) {
                banDuration = 999;
            }
            if (banDuration &lt; 0) {
                banDuration = 0;
            }
        }
    }

    return post('/api/friend', {
        api_type: 'json',
        uh: await getModhash(),
        type: action,
        name: user,
        r: subreddit,
        note: trimmedBanReason,
        ban_message: trimmedBanMessage,
        duration: banDuration,
        ban_context: banContext,
    });
}

/**
 * Removes a relationship between a user and a subreddit. Note that
 * this API method seems to always return 200 OK with a blank object
 * (`{}`) in response, so there's no meaningful error handling
 * possible here other than network errors.
 * @param {string} user The name of the user
 * @param {string} action The type of relationship to remove (see
 * {@link https://www.reddit.com/dev/api#POST_api_friend} for a list)
 * @param {string} subreddit The name of the subreddit
 * @returns {Promise} Resolves to the JSON response body or rejects
 * an error.
 */
export const unfriendUser = async (user, action, subreddit) => post('/api/unfriend', {
    api_type: 'json',
    uh: await getModhash(),
    type: action,
    name: user,
    r: subreddit,
});

/**
 * Mod-distinguishes a post or comment.
 * @function
 * @param {string} id The fullname of the post or comment
 * @param {boolean} sticky If distinguishing a top-level comment, whether to
 * also sticky the comment
 * @returns {Promise}
 */
export const distinguishThing = async (id, sticky) => post('/api/distinguish/yes', {
    id,
    sticky,
    uh: await getModhash(),
});

/**
 * Approves a post or comment.
 * @function
 * @param {string} id Fullname of the post or comment
 * @returns {Promise}
 */
export const approveThing = async id => post('/api/approve', {
    id,
    uh: await getModhash(),
});

/**
 * Removes a post or comment.
 * @function
 * @param {string} id Fullname of the post or comment
 * @param {boolean?} spam If true, removes as spam
 * @returns {Promise}
 */
export const removeThing = async (id, spam = false) => post('/api/remove', {
    uh: await getModhash(),
    id,
    spam,
});

/**
 * Ignores reports on a post or comment
 * @function
 * @param {string} id Fullname of the post or comment
 * @returns {Promise}
 */
export const ignoreReports = async id => post('/api/ignore_reports', {
    id,
    uh: await getModhash(),
});

/**
 * Marks a post as NSFW.
 * @function
 * @param {string} id Fullname of the post
 * @returns {Promise}
 */
export const markOver18 = async id => post('/api/marknsfw', {
    id,
    uh: await getModhash(),
});

/**
 * Un-marks a post NSFW.
 * @function
 * @param {string} id Fullname of the post
 * @returns {Promise}
 */
export const unMarkOver18 = async id => post('/api/unmarknsfw', {
    uh: await getModhash(),
    id,
});

/**
 * Locks a post or comment.
 * @param {string} id The fullname of the submission or comment
 * @returns {Promise} Resolves to response data or rejects with a jqXHR
 */
export const lock = async id => apiOauthPOST('/api/lock', {
    id,
    uh: await getModhash(),
});

/**
 * Unlocks a post or comment.
 * @param {string} id The fullname of the submission or comment
 * @returns {Promise} Resolves to response data or rejects with a jqXHR
 */
export const unlock = async id => post('/api/unlock', {
    uh: await getModhash(),
    id,
});

/**
 * Stickies a submission in a subreddit.
 * @param {string} id The fullname of the submission to sticky
 * @param {number} [num] The desired position of the sticky, either 1 or 2
 * @param {boolean} [state=true] Set to false to unsticky the thread (for
 * internal use only; use {@link unstickyThread} instead)
 * @returns {Promise} Resolves with response data or rejects a jqXHR
 */
export const stickyThread = async (id, num, state = true) => post('/api/set_subreddit_sticky', {
    id,
    num,
    state,
    uh: await getModhash(),
});

/**
 * Unstickies a submission.
 * @param {string} id The fullname of the submission to sticky
 * @returns {Promise} Resolves with response data or rejects a jqXHR
 */
export const unstickyThread = id => stickyThread(id, undefined, false);

/**
 * Posts a comment.
 * @function
 * @param {string} parent The fullname of the parent submission or comment
 * @param {string} text The text of the comment to post
 * @returns {Promise} Resolves to a response or rejects with an error or array of errors
 */
export const postComment = async (parent, text) => {
    try {
        const response = await post('/api/comment', {
            parent,
            uh: await getModhash(),
            text,
            api_type: 'json',
        });
        if (Object.prototype.hasOwnProperty.call(response.json, 'errors') &amp;&amp; response.json.errors.length > 0) {
            logger.log(`Failed to post comment to on ${parent}`);
            logger.log(response.json.fails);
            throw response.json.errors;
        }
        logger.log(`Successfully posted comment on ${parent}`);
        return response;
    } catch (error) {
        logger.log(`Failed to post link to on ${parent}`);
        logger.log(error);
        throw error;
    }
};

/**
 * Posts a link submission in a subreddit.
 * @function
 * @param {string} link The URL to submit
 * @param {string} title The title of the submission
 * @param {string} subreddit The subreddit to submit to
 * @returns {Promise} Resolves to a response or rejects with an error or array of errors
 */
export const postLink = async (link, title, subreddit) => {
    try {
        const response = await post('/api/submit', {
            kind: 'link',
            resubmit: 'true',
            url: link,
            uh: await getModhash(),
            title,
            sr: subreddit,
            sendreplies: 'true', // this is the default on reddit.com, so it should be our default.
            api_type: 'json',
        });
        if (Object.prototype.hasOwnProperty.call(response.json, 'errors') &amp;&amp; response.json.errors.length > 0) {
            logger.log(`Failed to post link to /r/${subreddit}`);
            logger.log(response.json.errors);
            throw response.json.errors;
        }
        logger.log(`Successfully posted link to /r/${subreddit}`);
        return response;
    } catch (error) {
        logger.log(`Failed to post link to /r/${subreddit}`);
        logger.log(error);
        throw error;
    }
};

/**
 * Sends a private message to a user.
 * @function
 * @param {string} user The name of the user to send the message to
 * @param {string} subject The message's subject
 * @param {string} message The message's content
 * @param {?string} [subreddit] If provided, sends the message as a modmail
 * from the specified subreddit
 * @returns {Promise} Resolves to a response or rejects with an error or array of errors
 */
export const sendMessage = async (user, subject, message, subreddit) => {
    try {
        const response = await post('/api/compose', {
            from_sr: subreddit,
            subject: subject.substr(0, 99),
            text: message.substr(0, 10000),
            to: user,
            uh: await getModhash(),
            api_type: 'json',
        });
        if (Object.prototype.hasOwnProperty.call(response.json, 'errors') &amp;&amp; response.json.errors.length > 0) {
            logger.log(`Failed to send link to /u/${user}`);
            logger.log(response.json.errors);
            throw response.json.errors;
        }
        logger.log(`Successfully send link to /u/${user}`);
        return response;
    } catch (error) {
        logger.log(`Failed to send link to /u/${user}`);
        logger.log(error);
        throw error;
    }
};

/**
 * Marks a message as read.
 * @param {string} id The fullname of the thing to mark as read
 * @returns {Promise}
 */
export const markMessageRead = async id => post('/api/read_message', {
    api_type: 'json',
    id,
    uh: await getModhash(),
});

/**
 * Gets information about a user.
 * @param {string} user The name of the user
 * @returns {Promise} Resolves to JSON user info or rejects with error text
 */
export const aboutUser = async user => getJSON(`/user/${user}/about.json`, {
    uh: await getModhash(),
}).then(response => {
    TBStorage.purifyObject(response);
    return response;
});

/**
 * Gets the timestamp of the last public activity on the user's profile.
 * @param {string} user The user to look for
 * @returns {Promise} Resolves to a number or rejects an error string
 */
export const getLastActive = async user => getJSON(`/user/${user}.json?limit=1&amp;sort=new`, {
    uh: await getModhash(),
}).then(response => {
    TBStorage.purifyObject(response);
    return response.data.children[0].data.created_utc;
}).catch(error => {
    throw error.responseText;
});

/**
 * Gets the rules for a subreddit
 * @param {string} subreddit The name of the subreddit
 * @returns {Promise} Resolves to the rules as JSON or rejects with an error string
 */
export const getRules = async sub => getJSON(`/r/${sub}/about/rules.json`, {
    uh: await getModhash(),
}).then(response => {
    TBStorage.purifyObject(response);
    return response;
});

/**
 * Gets the report reasons for a post by its URL
 * @param {string} postURL The absolute URL of a post
 * @returns {Promise} Resolves to an object containing the reports or throws an error string
 */
export const getReportReasons = async postURL => getJSON(`${postURL}.json?limit=1`, {
    uh: await getModhash(),
}).then(response => {
    TBStorage.purifyObject(response);
    if (typeof callback !== 'undefined') {
        const data = response[0].data.children[0].data;

        if (!data) {
            throw 'No reports returned';
        }

        return {
            user_reports: data.user_reports,
            mod_reports: data.mod_reports,
        };
    }
});

/**
 * Fetches a page of mod notes for the given user in the given subreddit.
 * @param {string} subreddit The name of the subreddit
 * @param {*} user The name of a user
 * @param {*} before ID of a mod note to search before (for pagination)
 * @returns {Promise} Resolves to an array of note objects or rejects an error
 */
export const getModNotes = (subreddit, user, before) => apiOauthGET('/api/mod/notes', {
    subreddit,
    user,
    before,
    limit: 100,
}).then(response => response.json()).then(response => {
    TBStorage.purifyObject(response);
    return response.mod_notes;
});

/**
 * For each given (user, subreddit) pair, fetches the most recent mod note for
 * that user in that subreddit.
 * @param {string[]} subreddits List of subreddit names
 * @param {string[]} users List of user names
 * @returns {Promise} Resolves to an array of note objects, where each
 * corresponds to the user and subreddit at the same index; if a given user has
 * no notes in the given subreddit, the corresponding item will be `null`
 */
export const getRecentModNotes = (subreddits, users) => apiOauthGET('/api/mod/notes/recent', {
    subreddits: subreddits.join(','),
    users: users.join(','),
}).then(response => response.json()).then(response => {
    TBStorage.purifyObject(response);
    return response.mod_notes;
});

/**
 * Creates a mod note on the given user in the given subreddit.
 * @param {object} data
 * @param {string} data.subreddit The name of the subreddit
 * @param {string} data.user The name of the user
 * @param {string} data.note The text of the note to add
 * @param {string} data.[label] One of Reddit's supported note labels
 * @param {string} data.[redditID] Fullname of an associated post or comment
 * @returns {Promise}
 */
export const createModNote = ({
    subreddit,
    user,
    note,
    label,
    redditID,
}) => apiOauthPOST('/api/mod/notes', {
    subreddit,
    user,
    note,
    label,
    reddit_id: redditID,
});

/**
 * Deletes a mod note on the given user in the given subreddit.
 * @param {object} data
 * @param {string} subreddit The name of the subreddit
 * @param {string} user The name of the user
 * @param {string} id The ID of the note
 * @returns {Promise}
 */
export const deleteModNote = ({subreddit, user, id}) => apiOauthDELETE('/api/mod/notes', {
    subreddit,
    user,
    note_id: id,
});
</code></pre>
        </article>
    </section>




    
    
</div>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 4.0.0</a> on Sat Jan 28 2023 20:24:48 GMT+0000 (Coordinated Universal Time) using the <a href="https://github.com/clenemt/docdash">docdash</a> theme.
</footer>

<script>prettyPrint();</script>
<script src="scripts/polyfill.js"></script>
<script src="scripts/linenumber.js"></script>

<script src="scripts/search.js" defer></script>



</body>
</html>
